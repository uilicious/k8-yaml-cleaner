#!/usr/local/bin/node

//-------------------------------------------------------
//
// Process CLI arguments
//
//-------------------------------------------------------

const CLI_ARGS_RAW = process.argv
const CLI_ARGS = CLI_ARGS_RAW.slice(2)

// Validate arguments
const MODE = CLI_ARGS[0]
if( MODE == null || (MODE != "-file" && MODE != "-string") ) {
	throw "Invalid yaml-cleaner command, example : node ./yaml-cleaner.js -file <filepath>"
}

//-------------------------------------------------------
//
// Dependencies
//
//-------------------------------------------------------

const fs = require("fs");

//-------------------------------------------------------
//
// Utility functions
//
//-------------------------------------------------------

/**
 * Get file string, given the file path
 * 
 * @param {String} filePath to get string value from
 * 
 * @return {String} value of file content
 */
function getFileStr(filePath) {
	return fs.readFileSync(filePath).toString()
}

/**
 * This safely escapes the given string for regex operations
 * 
 * @param {String} str 
 * @return {String} with regex safe formatted 
 */
function escapeRegExp(str) {
	return str.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
}

/**
 * Safely replace all instances of given string
 * 
 * @param {String} str 
 * @param {String} find 
 * @param {String} replace 
 * 
 * @return {String} with respective content replaced
 */
function replaceAll(str, find, replace) {
	return str.replace(new RegExp(escapeRegExp(find), 'g'), replace);
}

/**
 * Filter out lines which match the given prefix,
 * trim is applied before filtering
 * 
 * @param {Array} inArr containing strings 
 * @param {Array} prefixArray to filter out 
 * 
 * @return {Array} filtered array
 */
function filterStringArrayWithPrefixArrayAndTrim(inArr, prefixArr) {
	// Filter out line that matches the prefix (indexOf == 0)
	return inArr.filter(line => {
		for(let i=0; i<prefixArr.length; ++i) {
			if(line.trim().indexOf(prefixArr[i]) == 0) {
				// Match found, remove this line!
				return false;
			}
		}
		// No match found, line is valid
		return true;
	});
}

/**
 * Filter out lines which match the given prefix
 * 
 * @param {Array} inArr containing strings 
 * @param {Array} strArr to filter out 
 * 
 * @return {Array} filtered array
 */
function filterStringArrayWithStringxArray(inArr, strArr) {
	// Filter out line that matches the prefix (indexOf == 0)
	return inArr.filter(line => {
		for(let i=0; i<strArr.length; ++i) {
			if(line == strArr[i]) {
				// Match found, remove this line!
				return false;
			}
		}
		// No match found, line is valid
		return true;
	});
}

//-------------------------------------------------------
//
// YAML Cleaner constants
//
//-------------------------------------------------------

// Common unwanted yaml prefixes, autogenerated / defaulted by the system
const COMMON_UNWANTED_YAML_PREFIX = [

	// Autogenerated stuff
	"deprecated.daemonset.template.generation:",
	"field.cattle.io/creatorId:",
	"cattle.io/timestamp:",
	"creationTimestamp:",
	"cattle.io/creator:",
	"generation:",
	"resourceVersion:",
	"selfLink:",
	"uid:",
	"templateGeneration:",
	"field.cattle.io/publicEndpoints:",
	"deployment.kubernetes.io/revision:",

	// Default stuff
	"imagePullPolicy: Always",
	"resources: {}",
	"stdin: true",
	"terminationMessagePath: /dev/termination-log",
	"terminationMessagePolicy: File",
	"tty: true",
	"dnsPolicy: ClusterFirst",
	"restartPolicy: Always",
	"schedulerName: default-scheduler",
	"securityContext: {}",
	"terminationGracePeriodSeconds: 30",
	"revisionHistoryLimit: 10",

	// Status tracking
	"status:",
	"currentNumberScheduled:",
	"desiredNumberScheduled:",
	"numberAvailable:",
	"numberMisscheduled:",
	"numberReady:",
	"observedGeneration:",
	"updatedNumberScheduled:",
];

// Common unwanted yaml prefixes, autogenerated / defaulted by the system
const COMMON_UNWANTED_YAML_STRING = [
	// Status tracking
];

// Default security context filtering
const DEFAULT_SECURITY_CONTEXT = [
	"allowPrivilegeEscalation: false",
	"capabilities: {}",
	"privileged: false",
	"readOnlyRootFilesystem: false",
	"runAsNonRoot: false",
]

// To remove "SYMBOL"
const UNWANTED_LINE = "##### THIS IS A RESERVED AND UNWANTED LINE TO BE REMOVED #####"

//-------------------------------------------------------
//
// YAML Cleaner function
//
//-------------------------------------------------------

/**
 * Cleans up the given YAML string, for uneeded arguments,
 * or information that would be deployment specific.
 * 
 * This allows the output yaml to be made portable across multiple environments
 * 
 * @param {String} inputString 
 */
function yamlStringCleaner(inputString) {

	// Multiline safety
	if( inputString.indexOf("|-") >= 0 ) {
		throw "Multiline content detected : This is currently not supported!"
	}

	// Lets split the string first
	let strArr = inputString.split("\n")

	// Filter out the common stuff
	strArr = filterStringArrayWithPrefixArrayAndTrim(strArr, COMMON_UNWANTED_YAML_PREFIX);
	strArr = filterStringArrayWithStringxArray(strArr, COMMON_UNWANTED_YAML_STRING);

	// Filter out specifically the "kubectl.kubernetes.io/last-applied-configuration: |"
	for(let lineNum=0; lineNum < strArr.length; ++lineNum) {
		let triggerLine = strArr[lineNum];
		let triggerLineTrim = triggerLine.trim();

		// The last-applied-configuration: | 
		if( triggerLineTrim == "kubectl.kubernetes.io/last-applied-configuration: |" ) {
			strArr[lineNum+0] = UNWANTED_LINE;
			strArr[lineNum+1] = UNWANTED_LINE;
		}
		if( triggerLineTrim.indexOf("kubectl.kubernetes.io/last-applied-configuration:") == 0 ) {
			strArr[lineNum+0] = UNWANTED_LINE;
		}
	}

	// Final UNWANTED_LINE filter
	strArr = strArr.filter(line => { return line != UNWANTED_LINE })

	// Filter out the more "complex" sequences
	for(let lineNum=0; lineNum < strArr.length; ++lineNum) {
		let triggerLine = strArr[lineNum];
		let triggerLineTrim = triggerLine.trim();

		// Remove "blank" annotations
		if( triggerLineTrim == "annotations:" ) {
			let nextLine = strArr[lineNum+1] || "";
			let nextLineTrim = nextLine.toString().trim();
			if( nextLineTrim == "" || nextLineTrim.indexOf("labels:") >= 0 || nextLineTrim.indexOf("name:") >= 0 ) {
				strArr[lineNum] = UNWANTED_LINE;
			}
		}

		// Remove "default" securityContext:
		if( triggerLineTrim == "securityContext:" ) {
			if(
				(strArr[lineNum+1] || "").trim() == "volumeMounts:"
			) {
				strArr[lineNum] = UNWANTED_LINE;
			} else if( 
				(strArr[lineNum+1] || "").trim() == DEFAULT_SECURITY_CONTEXT[0] &&
				(strArr[lineNum+2] || "").trim() == DEFAULT_SECURITY_CONTEXT[1] &&
				(strArr[lineNum+3] || "").trim() == DEFAULT_SECURITY_CONTEXT[2] &&
				(strArr[lineNum+4] || "").trim() == DEFAULT_SECURITY_CONTEXT[3] &&
				(strArr[lineNum+5] || "").trim() == DEFAULT_SECURITY_CONTEXT[4]
			) {
				strArr[lineNum+0] = UNWANTED_LINE;
				strArr[lineNum+1] = UNWANTED_LINE;
				strArr[lineNum+2] = UNWANTED_LINE;
				strArr[lineNum+3] = UNWANTED_LINE;
				strArr[lineNum+4] = UNWANTED_LINE;
				strArr[lineNum+5] = UNWANTED_LINE;
			}
		}

		// Remove default updateStrategy
		if( triggerLineTrim == "updateStrategy:" ) {
			if(
				(strArr[lineNum+1] || "").trim() == "rollingUpdate:" &&
				(strArr[lineNum+2] || "").trim() == "maxUnavailable: 1" &&
				(strArr[lineNum+3] || "").trim() == "type: RollingUpdate"
			) {
				strArr[lineNum+0] = UNWANTED_LINE;
				strArr[lineNum+1] = UNWANTED_LINE;
				strArr[lineNum+2] = UNWANTED_LINE;
				strArr[lineNum+3] = UNWANTED_LINE;
			}
		}
	}

	// Filter out default securityContext:, leaving non default
	strArr = filterStringArrayWithPrefixArrayAndTrim(strArr, DEFAULT_SECURITY_CONTEXT);

	// Final UNWANTED_LINE filter
	strArr = strArr.filter(line => { return line != UNWANTED_LINE })

	// Does the final join back together
	return strArr.join("\n")
}

//-------------------------------------------------------
//
// Actual script execution
//
//-------------------------------------------------------

// Lets get the yaml file content
let ORIGINAL_YAML = null;
if( MODE == "-file" ) {
	ORIGINAL_YAML = getFileStr( CLI_ARGS[1] )
} else {
	throw "Unknown yaml-cleaner mode : "+MODE;
}

// And clean it out and return it
console.log( yamlStringCleaner(ORIGINAL_YAML) );
